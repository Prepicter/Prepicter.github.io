[ { "title": "mediapipe-model-maker retraining시 문제해결", "url": "/posts/mediapipe-retraining-error/", "categories": "Python, mediapipe", "tags": "tips", "date": "2024-08-21 13:00:00 +0900", "snippet": "mediapipe-model-maker retraining시 문제해결Received incompatible tensor with shape (5,) when attempting to restore variable with shape (3,) and name dense_1/bias:0.이전에 작업한 checkpoint가 남아있어서 발생. 해당 폴더 제거시 정상 작동" }, { "title": "python으로 바로가기 파일(.lnk) 실제 주소 확인법", "url": "/posts/address-of-lnk-file/", "categories": "Python", "tags": "tips", "date": "2024-01-09 13:00:00 +0900", "snippet": "python으로 바로가기 파일(.lnk) 실제 주소 확인법import win32com.clientshell = win32com.client.Dispatch(\"WScript.Shell\")shell.CreateShortCut(lnk_path).Targetpath]C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Accessories\\wordpad.lnk-&gt;C:\\Program Files\\Windows NT\\Accessories\\wordpad.exe참고 https://stackoverflow.com/questions/65572953/how-to-get-the-real-path-of-shortcut" }, { "title": "Maple rune solver", "url": "/posts/Maple-Rune-Solver/", "categories": "ML", "tags": "object-detection, yolo", "date": "2022-12-24 21:00:00 +0900", "snippet": "22년도 여름방학 프로젝트Object Detection 공부 용으로 시작목표는 룬 해방시 생기는 화살표를 정확하게 맞추는것공부 목적. 악의적인 목적으로 사용하지 않음초기 설계CNN 만으로 구현을 시도하였음 게임 화면에서 룬 영역을 추출 룬 영역을 일정 간격으로 4개를 슬라이싱 각 이미지를 CNN으로 분류CNN 분류기는 기본 500장의 라벨링된 데이터에 색조와 방향을 조정하고, 노이즈를 추가하여 데이터를 증식시켰고, 약 1500장의 이미지를 학습데이터로 사용하였다.추출된 룬 영역이상적인 슬라이싱문제가 되는 경우 \t 발생한 문제점 룬은 랜덤한 간격을 가진다 -&gt; 넉넉하게 슬라이싱해도 서로 섞이는 문제 발생 위의 문제점으로 화살표의 위치가 들쭉날쭉이라 분류의 정확도가 감소초기 설계 개선어짜피 이미지가 섞인다면 차라리 전체 룬 영역 이미지에서 CNN의 방식처럼 일정 간격(stride)으로 조금씩 이동하면서 각각 분류시킨후 분포에 따라 분류를 시키기조금씩 이동분포참고로 left right top top 이였다.결과 시도는 좋았으나, 잘려진 부분의 이미지를 잘 분류하지는 못했다. 이전보단 결과가 좋긴한데, 그래도 분류에 오류 발생Object Detection 사용이전 방식으로 계속 하다간 끝이 안날것 같아 변경Yolo v4를 사용하였다.변경된 설계 룬 영역 추출 까지는 동일. 이미지 사이즈를 416x416으로 확장 이미지를 통째로 Yolo에 넣기 결과 출력416 사이즈로 뽑기출력결과 룬 자체는 잘 찾았다. 다만 방향을 제대로 분류하진 못했다. Yolo가 방향성도 고려하여 학습을 하나? 학습 데이터(약 1500장)가 적어서 그럴지도분류기 추가 어짜피 룬 자체는 잘 찾으니, 찾은 룬 이미지를 그대로 분류기에 넣어버리기. 이미지 사이즈가 다르니, 학습데이터를 조정후 다시 학습시켰다.분류기에 넣기출력[5.5755044e-17 2.5297098e-11 1.0000000e+00 2.5603323e-13] right결과 잘 찾아내고 분류도 잘함 실제 게임에서 약 500번 정도 룬 이미지를 수집하고, 돌려봤는데 놀랍게도 실패는 없더라.끝내면서 Yolo는 ROI를 찾으면서 동시에 분류를 하여 속도가 빠르다. 근데 여기서는 분류기를 추가로 넣었으니 의미가 없지 않나. 차라리 Masked R-CNN으로 만들었다면, 추가로 분류기를 안 넣어도 잘 찾지 않았을까?" }, { "title": "Yolo4 가중치 Tf 변환 오류", "url": "/posts/Yolo4-%EA%B0%80%EC%A4%91%EC%B9%98-tf-%EB%B3%80%ED%99%98-%EC%98%A4%EB%A5%98/", "categories": "ML", "tags": "yolo, weight", "date": "2022-08-27 14:00:00 +0900", "snippet": "ValueError: cannot reshape array of size 379318 into shape (256,256,3,3)직접 학습된 가중치 파일의 클래스 크기가 기본 yolo4와 맞지 않아서 발생data 폴더에 자신의 class.names 파일을 넣고core/config.py 의 class 부분에 자기 class 이름을 넣기참고 https://github.com/hunglc007/tensorflow-yolov4-tflite/issues/126" }, { "title": "불균형 데이터 균형화", "url": "/posts/%EB%B6%88%EA%B7%A0%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B7%A0%ED%98%95%ED%99%94/", "categories": "ML", "tags": "titanic, imbalanced-learn, sampling", "date": "2022-08-03 17:00:00 +0900", "snippet": "불균형 데이터 균형화(imbalanced-learn)타이타닉 생존자 데이터셋 비율# 생존비 확인print(train_df.loc[train_df['Survived'] == 1].shape)print(train_df.loc[train_df['Survived'] == 0].shape)(341, 12)(963, 12)언더 샘플링from imblearn.under_sampling import RandomUnderSamplerX_data = train_dfy_data = train_df.pop('Survived')Y1 = np.where(y_data == 1)Y0 = np.where(y_data == 0)sampler = RandomUnderSampler(random_state = 0)X_data, y_data = smote.fit_resample(X_data, y_data)print(np.sum(y_data == 1), np.sum(y_data == 0))341 341오버 샘플링from imblearn.over_sampling import RandomOverSamplerX_data = train_dfy_data = train_df.pop('Survived')Y1 = np.where(y_data == 1)Y0 = np.where(y_data == 0)sampler = RandomOverSampler(random_state = 0)X_data, y_data = smote.fit_resample(X_data, y_data)print(np.sum(y_data == 1), np.sum(y_data == 0))963 963SMOTEfrom imblearn.over_sampling import SMOTEX_data = train_df_newy_data = train_df_new.pop('Survived')Y1 = np.where(y_data == 1)Y0 = np.where(y_data == 0)smote = SMOTE(random_state=0)X_data, y_data = smote.fit_resample(X_data, y_data)print(np.sum(y_data == 1), np.sum(y_data == 0))963 963참고 머신러닝 데이터 전처리 입문 - 아다치 하루카" }, { "title": "타이타닉 데이터셋 분류", "url": "/posts/%ED%83%80%EC%9D%B4%ED%83%80%EB%8B%89-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%85%8B-%EB%B6%84%EB%A5%98/", "categories": "ML", "tags": "titanic, ml, classifier", "date": "2022-07-30 22:00:00 +0900", "snippet": "Titanic 데이터 셋 처리하기데이터셋 링크https://www.kaggle.com/c/titanic/구조 Variable Definition key survival survival 0 = No, 1 = Yes pclass Ticket class 1 = 1st, 2 = 2nd, 3 = 3rd sex Sex   Age Age in years   sibsp # of siblings / spouses aboard the Titanic   parch # of parents / children aboard the Titanic   ticket Ticket number   fare Passenger fare   cabin Cabin number   embarked Port of Embarkation C = Cherbourg, Q = Queenstown, S = Southampton 데이터셋 살펴보기import numpy as npimport pandas as pdtrain_df = pd.read_csv('datasets/train.csv')test_df = pd.read_csv('datasets/test.csv')# 그냥 두개 합친다. 나중에 전처리 후 나누기train_df = pd.concat([train_df, test_df])train_df.head() 데이터 개수와 타입 print(train_df.shape)print(train_df.dtypes) 데이터 전처리 결측값 확인print(train_df.isnull().sum(axis=0))비어있는 Survived와 Age는 중앙값으로 대체하고, 나머지 결측값 행 드랍train_df['Survived'] = train_df['Survived'].fillna(train_df['Survived'].median())train_df['Age'] = train_df['Age'].fillna(train_df['Age'].median())train_df.dropna(axis=0, inplace=True) 문자 -&gt; 숫자성별은 문자로 되어있으므로 숫자로 바꾼다.train_df['Sex'].replace('male', 0, inplace=True)train_df['Sex'].replace('female', 1, inplace=True)Embarked는 원핫벡터로 나눈다.train_df_embarked = pd.get_dummies(train_df['Embarked'])train_df = pd.concat([train_df, train_df_embarked], axis=1)train_df_embarked.head()Ticket은 문자와 숫자로 구성되어있는데, 혹시 모르니 숫자만 분리해보자import reticket_filter = r'(\\d+$)'train_df['Ticket'] = train_df['Ticket'].str.extract(ticket_filter)train_df['Ticket'] = pd.to_numeric(train_df['Ticket'])분류에 필요 없어 보이는 문자행을 없앤다.train_df.drop(['Name', 'Cabin', 'Embarked'], axis=1, inplace=True)상관계수 확인train_df.corr()Pclass, 성별, 요금 정도가 생존과 관련 있어 보인다.분류데이터 분리from sklearn.model_selection import train_test_splitX_data = train_dfy_data = train_df.pop('Survived')X_train, X_test, y_train, y_test = train_test_split(X_data, y_data, random_state=0)정규화from sklearn.preprocessing import StandardScalerscaler = StandardScaler()X_train_scaled = scaler.fit_transform(X_train)X_train_scaled = pd.DataFrame(X_train_scaled, columns=X_data.columns)X_test_scaled = scaler.transform(X_test)X_test_scaled = pd.DataFrame(X_test_scaled, columns=X_data.columns)결정트리from sklearn.tree import DecisionTreeClassifierclf = DecisionTreeClassifier().fit(X_train_scaled, y_train)print('Accuracy of Decision Tree classifier on training set: {:.3f}'\t\t.format(clf.score(X_train_scaled, y_train)))print('Accuracy of Decision Tree classifier on test set: {:.3f}'\t\t.format(clf.score(X_test_scaled, y_test)))Accuracy of Decision Tree classifier on training set: 1.000Accuracy of Decision Tree classifier on training set: 0.838끝으로 MinMaxScaler랑 별 차이는 없는듯. Ticket은 숫자만 추출해봤지만, 큰 의미는 없었다. 중요한 데이터가 몇 개 없는 것을 보면 다른 알고리즘을 써도 비슷한 결과가 나올 것 같다. 내가 놓친 데이터가 있을 것 같은데.." }, { "title": "안녕하세요", "url": "/posts/%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94/", "categories": "etc", "tags": "just", "date": "2022-07-29 22:30:00 +0900", "snippet": "작성 테스트안녕하세요. 환영합니다. 머신러닝을 공부하고있습니다Hello World!" } ]
